<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>blog.wamser.eu - Let's Encrypt Gatling</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">blog.wamser.eu</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Let's Encrypt Gatling</h1>

            <div class="info">
    Posted on April 12, 2016
    
</div>

<p>I’m in the process of moving my personal data from cloudy venues to my own server, where I want to access it over https. For that purpose I want a <a href="https://letsencrypt.org/">Let’s Encrypt</a>-certificate, but not the client with all its dependencies on my server, especially as I’m going to set up <a href="https://www.fefe.de/gatling/">gatling</a>, which is not supported by the official tools.</p>
<p>Fortunately, there is <a href="https://gethttpsforfree.com/">gethttpsforfree.com</a> which walks you through the process. Be sure to also read <a href="https://github.com/diafygi/gethttpsforfree">github.com/diafygi/gethttpsforfree</a> to understand what is going on.</p>
<p>For convenience (and my own future reference), I will explain each step a bit further here. Note that all is done on the target server (a Debian Jessie in my case) to avoid issues arising from a different SSL configuration on the client (ArchLinuxARM).</p>
<p>If you want to repeat the steps below, kindly note that you need to have a machine up and running that can be contacted via port 80 ont the public side at the domain(s) you want a certificate for. That means also configuring your router with port forwarding, setting up (dynamic) DNS etc., if you are running a home server.</p>
<h2 id="step-1">Step 1:</h2>
<p><strong><em>If you did this step before, proceed directly to step 2.</em></strong></p>
<ol start="0" style="list-style-type: decimal">
<li>Decide on the eMail-Address to use.</li>
<li>Generate your master key, which will be the anchor of any communication with Let’s Encrypt. Do not lose it. Backup and Protect.</li>
</ol>
<pre><code>   openssl genrsa -out account.key 4096 -aes256

   export PRIV_KEY=$(pwd)/account.key
   openssl rsa -in account.key -pubout</code></pre>
<p>(the variable <code>PRIV_KEY</code> will come in handy in step 3)</p>
<p>Put your eMail-Address and the output of the last <code>openssl</code>-command in the appropriate boxes under Step 1 on <a href="https://gethttpsforfree.com/">gethttpsforfree.com</a>. This will submit you <strong><em>public</em></strong> key and your eMail-Address to Let’s Encrypt.</p>
<p>(In theory, a man-in-the-middle could be attempted by that page by swapping in its public key at this point. But that would be discovered later unless it can also impersonate your server to Let’s Encrypt.)</p>
<p>Backup your <code>account.key</code> file to a safe and secure place, then click on <code>Validate Account Info</code>.</p>
<h2 id="step-2">Step 2:</h2>
<p>Now we will create the certificate that is actually used for the server.</p>
<p>Make a list of all the domain names that this certificate will cover. These names are likely different from your local machine name. You probably <code>ssh</code>’d into your home server with <code>ssh root@bloodybox</code>, but you set it up to be accessible as <code>http(s)://rainbowpony.wamser.eu</code>. Then <code>rainbowpony.wamser.eu</code> is the name you want to put on your list.<br />
Ready? Good.</p>
<h3 id="generate-the-key-for-your-sites">1. Generate the key for your site(s):</h3>
<p><code>openssl genrsa -out account.key 4096</code></p>
<p>This time we did not ask to encrypt the output, as your server needs to see the key in plain later.</p>
<p>You could use this key already for your page (for testing the setup and so on), but it will give you a warning in your browser. So we will ask Let’s Encrypt to sign this certificate. The formal way of asking is creating a Certificate Signing Request or CSR as we pros call it.</p>
<h3 id="generate-csr">2. Generate CSR</h3>
<p><code>openssl req -new -sha256 -key domain.key -subj &quot;/&quot; \   -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf \   &lt;(printf &quot;[SAN]\nsubjectAltName=DNS:rainbowpony.wamser.eu,DNS:drunkenunicorn.wamser.eu&quot;))</code></p>
<p>Note that you likely need to change <code>/etc/ssl/openssl.cnf</code> to another path if you are not running Debian. And I’m pretty sure we need to change the domain names. Put in the ones you noted down before, each prefixed with <code>DNS:</code> and separated by <code>,</code>.</p>
<h3 id="submit">2. Submit</h3>
<p>Copy the output in the box under Step 2 on <a href="https://gethttpsforfree.com/">gethttpsforfree.com</a> and click <code>Validate CSR</code></p>
<h2 id="step-3">Step 3</h2>
<p>Now Let’s Encrypt asks back to make sure you have the private key for the public key you submitted in step 1. You are asked to run a few commands (compute a few signatures). Copy the lines from <code>echo</code> to the end, paste to your shell, check that they are doing nothing evil (they should only <code>echo</code> a string to <code>openssl</code>) and run them. Paste the results to the appropriate text boxes on <a href="https://gethttpsforfree.com/">gethttpsforfree.com</a>. Now you should also understand why we kept the path to the private key at hand.</p>
<h2 id="step-4">Step 4</h2>
<p>Now Let’s Encrypt wants to make sure you actually control the domain you want the certificate for. You can either do this by running a mini-server with python or putting a specific file on the http-without-s server you have running there. In both cases you will provide some individual data that just has been generated for you.</p>
<p>If you choose the python server, you can adjust the port in line 4 of the script to match any port-forwarding rule, if needed. Note that externally it should be accessible on port 80.</p>
<p>As I am going to use <a href="https://www.fefe.de/gatling/">gatling</a> anyway, here’s for the file based method.</p>
<p>We are asked to serve a file at <code>http://rainbowpony.wamser.eu/.well-known/acme-challenge/randomfilename</code> with a specific content.</p>
<p>This is quickly done. We’ll use <code>/var/www/default</code> to hold the file.</p>
<p>So on your server run (after setting the variables to what you copied from gethttpsforfree.com):</p>
<pre><code>export LE_URL=theURLgiven
export LE_CONTENT=theContentgiven
cd /var/www/default
mkdir .well-known
chmod o+r .well-known
mkdir .well-known/acme-challenge
chmod o+r .well-known/acme-challenge
ln -s .well-known \:well-known
echo $LE_CONTENT &gt; .well-known/acme-challenge/$(echo $LE_URL | sed -n 's/.*acme-challenge\/\(.*\)/\1/p')
chmod o+r .well-known/acme-challenge/$(echo $LE_URL | sed -n 's/.*acme-challenge\/\(.*\)/\1/p')
gatling -p 80 -t</code></pre>
<p>Adjust the port option (<code>-p</code>) of <code>gatling</code> as needed.</p>
<p>Make sure the file is accessible via the specified URL, run the signature as in step 3, then click <code>I'm now serving this file...</code></p>
<h2 id="step-5---your-certificate">Step 5 - Your certificate!</h2>
<p>You made it! You can now download your signed ceritificate and the intermediate certificate from the two text boxes. Installation hints for <code>nginx</code> and Apache are given on the page. Installation for <code>gatling</code> is the next (final) step.</p>
<p>If you want, you can also click the <code>Test my page</code> button. This will take you to <code>https://www.ssllabs.com/ssltest/analyze.html?d=yourdomain</code>.</p>
<p><strong><em>You need to repeat steps 2 through 5 every 90 days!</em></strong></p>
<p>Remember your certificate expires after 90 days, so you will need to renew in time. Either follow this guide or go the way to automation. In the latter case the <a href="https://github.com/letsencrypt/letsencrypt/wiki/Links">official list of inofficial clients</a> might be useful.</p>
<h2 id="step-6---setup-gatling-with-the-certificates.">Step 6 - Setup gatling with the certificates.</h2>
<p>Assuming you copied your certificate and the intermediate certificate (in that order) into a file <code>le-certs.pem</code>. Now you just need to prepend the private key from Step 2 to it, using somthing like</p>
<pre><code>   cat path/to/domain.key le-certs.pem &gt; server.pem</code></pre>
<p>Copy the <code>server.pem</code> file to your webroot. For <a href="http://permalink.gmane.org/gmane.comp.web.gatling/302">SNI-support</a> also set a symlink (adjust your domain name!):</p>
<pre><code>  ln -s baconburrito.wamser.eu.pem server.pem</code></pre>
<p>(Re)Start <code>gatling</code> (adjust options as required).</p>
<pre><code>tlsgatling -V -t -D -F -I &quot;index.html&quot; -S -e -p 443 -u gatwww</code></pre>
<p>That’s it. Enjoy your server.</p>
<h2 id="last-words">Last Words</h2>
<p>Let’s Encrypt is currently adding support for EC-based certificates. I will update this post in due time, also with details on renewing the certificate.</p>

        </div>
        <div id="footer">
            <a href="../impressum.html">Impressum</a>
        </div>
    </body>
</html>
